#!/usr/bin/env bash
set -euo pipefail
# v3 ‚Äî –≤—Å–µ–≥–¥–∞ –∏—Å–ø–æ–ª—å–∑—É–µ–º sysfs-–ø—É—Ç—å: -p /sys/class/net/$IFACE

UDEV_RULES=0
if [[ "${1:-}" == "--udev" ]]; then UDEV_RULES=1; shift; fi

if [[ $EUID -ne 0 ]]; then
  echo "–ó–∞–ø—É—Å—Ç–∏ –æ—Ç root (sudo)." >&2; exit 1
fi
if [[ $# -lt 1 ]]; then
  echo "–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: $0 [--udev] enpX=modem1 enpY=modem2 ..." >&2; exit 1
fi

LINK_DIR="/etc/systemd/network"
RULES_DIR="/etc/udev/rules.d"
mkdir -p "$LINK_DIR" "$RULES_DIR"

timestamp="$(date +%Y%m%d-%H%M%S)"
tmp_trigger_list="$(mktemp)"

valid_name() { [[ "$1" =~ ^[a-z0-9_.:-]+$ ]]; }

create_link_file() {
  local new="$1" id_path="$2" driver="$3"
  local f="$LINK_DIR/10-${new}.link"
  cat >"$f" <<EOF
# autogenerated by persist-net-names.sh on $timestamp
[Match]
Path=${id_path}
${driver:+Driver=${driver}}

[Link]
Name=${new}
EOF
  echo "üìù .link: $f"
}

append_udev_rule() {
  local new="$1" id_path="$2" ven="$3" prod="$4"
  local f="$RULES_DIR/70-persist-modems.rules"
  local rule="SUBSYSTEM==\"net\", ACTION==\"add\", ENV{ID_PATH}==\"${id_path}\"${ven:+, ENV{ID_VENDOR_ID}==\"$ven\"}${prod:+, ENV{ID_MODEL_ID}==\"$prod\"}, NAME=\"${new}\""
  if ! grep -Fq "$rule" "$f" 2>/dev/null; then
    echo "$rule" >> "$f"
    echo "üìù udev rule –¥–æ–±–∞–≤–ª–µ–Ω: $f"
  else
    echo "‚ÑπÔ∏è  udev rule —É–∂–µ –µ—Å—Ç—å: $f"
  fi
}

for pair in "$@"; do
  [[ "$pair" == *"="* ]] || { echo "‚ùå –ê—Ä–≥—É–º–µ–Ω—Ç '$pair' –Ω–µ –≤–∏–¥–∞ IFACE=NAME"; continue; }
  cur="${pair%%=*}"
  new="${pair#*=}"

  if [[ ! -e "/sys/class/net/$cur" ]]; then
    echo "‚ùå –ò–Ω—Ç–µ—Ä—Ñ–µ–π—Å '$cur' –Ω–µ –Ω–∞–π–¥–µ–Ω (/sys/class/net/$cur). –ü—Ä–æ–ø—É—Å–∫–∞—é."
    continue
  fi
  if ! valid_name "$new"; then
    echo "‚ùå –ù–æ–≤–æ–µ –∏–º—è '$new' –Ω–µ–¥–æ–ø—É—Å—Ç–∏–º–æ (^[a-z0-9_.:-]+$). –ü—Ä–æ–ø—É—Å–∫–∞—é."
    continue
  fi
  if [[ -e "/sys/class/net/$new" ]]; then
    echo "‚ùå –í —Å–∏—Å—Ç–µ–º–µ —É–∂–µ –µ—Å—Ç—å –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å '$new'. –ü—Ä–æ–ø—É—Å–∫–∞—é."
    continue
  fi

  sysfs="/sys/class/net/$cur"
  props="$(udevadm info -q property -p "$sysfs")" || props=""

  id_path="$(sed -n 's/^ID_PATH=//p' <<<"$props" | head -n1)"
  driver="$(sed -n 's/^ID_NET_DRIVER=//p' <<<"$props" | head -n1)"
  ven="$(sed -n 's/^ID_VENDOR_ID=//p' <<<"$props" | head -n1)"
  prod="$(sed -n 's/^ID_MODEL_ID=//p' <<<"$props" | head -n1)"
  devpath_full="$(sed -n 's/^DEVPATH=//p' <<<"$props" | head -n1)"

  echo "‚Üí $cur:"
  echo "   sysfs: $sysfs"
  [[ -n "$devpath_full" ]] && echo "   DEVPATH: $devpath_full"
  echo "   ID_PATH: ${id_path:-<none>}"
  echo "   Driver: ${driver:-<none>}"

  if [[ -z "$id_path" ]]; then
    echo "‚ö†Ô∏è  ID_PATH –Ω–µ –Ω–∞–π–¥–µ–Ω (—Ä–µ–¥–∫–æ, –Ω–æ –±—ã–≤–∞–µ—Ç). –ü–æ–ø—Ä–æ–±—É–µ–º fallback –∏–∑ udevadm info -a‚Ä¶"
    # Fallback: –ø–æ–ø—ã—Ç–∞—Ç—å—Å—è –≤—ã—Ç–∞—â–∏—Ç—å –ø—É—Ç—å —Ä–æ–¥–∏—Ç–µ–ª—å—Å–∫–æ–≥–æ USB-–∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞
    id_path="$(udevadm info -a -p "$sysfs" 2>/dev/null | sed -n 's/^ *ATTRS{devpath}==\"\(.*\)\".*$/\1/p' | head -n1)"
    if [[ -n "$id_path" ]]; then
      echo "   Fallback ID_PATH(candidate): $id_path"
    else
      echo "‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å —Å—Ç–∞–±–∏–ª—å–Ω—ã–π Path –¥–ª—è '$cur'. –ü—Ä–æ–ø—É—Å–∫–∞—é."
      continue
    fi
  fi

  create_link_file "$new" "$id_path" "$driver"
  [[ $UDEV_RULES -eq 1 ]] && append_udev_rule "$new" "$id_path" "$ven" "$prod"

  echo "$sysfs" >> "$tmp_trigger_list"
  echo "‚úÖ ${cur} ‚Üí ${new}"
done

echo
echo "‚Üª –ü–µ—Ä–µ–∑–∞–≥—Ä—É–∂–∞—é –ø—Ä–∞–≤–∏–ª–∞‚Ä¶"
udevadm control --reload || true
systemctl daemon-reload || true

if [[ -s "$tmp_trigger_list" ]]; then
  while read -r p; do
    [[ -e "$p" ]] || continue
    echo "‚Üí udevadm trigger -c add $p"
    udevadm trigger -c add "$p" || true
  done < "$tmp_trigger_list"
fi

echo
echo "–ì–æ—Ç–æ–≤–æ. –ï—Å–ª–∏ –∏–º–µ–Ω–∞ –Ω–µ —Å–º–µ–Ω–∏–ª–∏—Å—å —Å—Ä–∞–∑—É ‚Äî –ø–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–∏ –º–æ–¥–µ–º—ã –∏–ª–∏ –ø–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∏ –º–∞—à–∏–Ω—É."
echo "–§–∞–π–ª—ã: .link –≤ ${LINK_DIR} ${UDEV_RULES:+; udev-–ø—Ä–∞–≤–∏–ª–∞ –≤ ${RULES_DIR}/70-persist-modems.rules}"
